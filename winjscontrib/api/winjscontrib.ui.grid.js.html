<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>WinJS Contrib Source: winjscontrib.ui.grid.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">WinJS Contrib</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#WinJSContrib">WinJSContrib</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Alerts.html">Alerts</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Bindings.html">Bindings</a>
						</li>
						
						<li>
							<a href="WinJSContrib.CrossPlatform.html">CrossPlatform</a>
						</li>
						
						<li>
							<a href="WinJSContrib.CrossPlatform.isMobile.html">isMobile</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.html">Logging</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.Appenders.html">Appenders</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.html">Search</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.html">Stemming</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.Op.html">Op</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.StopWords.html">StopWords</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Templates.html">Templates</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.html">UI</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.Animation.html">Animation</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataForm.Converters.html">Converters</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.html">DataSources</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.Grouping.html">Grouping</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Utils.html">Utils</a>
						</li>
						
						<li>
							<a href="WinJSContrib.WinRT.html">WinRT</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="WinJSContrib.Logging.Appenders.ConsoleAppender.html">ConsoleAppender</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.LoggerClass.html">LoggerClass</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Messenger.html">Messenger</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Messenger.SmartWorker.html">SmartWorker</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Index.html">Index</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.IndexGroup.html">IndexGroup</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.IndexWorkerProxy.html">IndexWorkerProxy</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.Pipeline.html">Pipeline</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.ChildViewFlyout.html">ChildViewFlyout</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataForm.html">DataForm</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.DataSourceManager.html">DataSourceManager</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.EventTracker.html">EventTracker</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.ExtendedSplash.html">ExtendedSplash</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FlipViewPager.html">FlipViewPager</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FluentDOM.html">FluentDOM</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FlyoutPage.html">FlyoutPage</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.GlobalProgress.html">GlobalProgress</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.GridControl.html">GridControl</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.HubControl.html">HubControl</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MediaTrigger.html">MediaTrigger</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MultiPassItem.html">MultiPassItem</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MultiPassRenderer.html">MultiPassRenderer</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.PageControlNavigator.html">PageControlNavigator</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.SemanticListViews.html">SemanticListViews</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.SmartListLayout.html">SmartListLayout</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UPnP.UPnPDevice.html">UPnPDevice</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: winjscontrib.ui.grid.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">/* 
 * WinJS Contrib v2.0.3.0
 * licensed under MIT license (see http://opensource.org/licenses/MIT)
 * sources available at https://github.com/gleborgne/winjscontrib
 */

(function () {

	"use strict";

	/**
     * Object representing a layout configuration for the grid control
     * @typedef {Object} WinJSContrib.UI.GridControlLayout
     * @property {string} layout layout algorythm to apply (horizontal | vertical | flexhorizontal | flexvertical | hbloc
     * @property {number} cellSpace space between grid cells
     * @property {number} cellWidth width of grid cells
     * @property {number} cellHeight height of grid cells
     * @property {number} itemsPerColumn number of cells per column if using a layout with a fixed number of cells
     * @property {number} itemsPerRow number of cells per row if using a layout with a fixed number of cells
     * @example
     * {
     *     layout: 'horizontal',
     *     itemsPerColumn: (options.itemsPerColumn) ? options.itemsPerColumn : undefined,
     *     itemsPerRow: (options.itemsPerRow) ? options.itemsPerRow : undefined,
     *     cellSpace: 10,
     *     cellWidth: (options.cellWidth) ? options.cellWidth : undefined,
     *     cellHeight: (options.cellHeight) ? options.cellHeight : undefined,
     * }
     */

	WinJS.Namespace.define("WinJSContrib.UI", {
		GridControl: WinJS.Class.define(
            /**
             * @classdesc
             * Control that layout it's children with different algorythms. Used with {@link WinJSContrib.UI.Hub}, The Grid could rely on multipass rendering to optimize large hub pages load.
             * @class WinJSContrib.UI.GridControl
             * @param {HTMLElement} element DOM element containing the control
             * @param {Object} options
             */
            function GridControl(element, options) {
            	var grid = this;
            	options = options || {};
            	grid.element = element;

            	grid.element.className = grid.element.className + ' mcn-grid-ctrl mcn-layout-ctrl win-disposable';
            	grid.element.winControl = grid;
            	/**
                 * indicate if grid accept layout event from the page (if you use WinJS Contrib page events)
                 * @field
                 * @type boolean
                 */
            	grid.autolayout = options.autolayout;
            	if (grid.autolayout) {
            		var parent = WinJSContrib.Utils.getScopeControl(grid.element);
            		if (parent &amp;&amp; parent.elementReady) {
            			parent.elementReady.then(function () {
            				if (!parent.beforeShow) parent.beforeShow = [];
            				parent.beforeShow.push(function () {
            					grid.layout();
            				});
            				return parent.renderComplete;
            			});
            		}
            	}

            	/**
                 * multipass renderer for the grid
                 * @field
                 * @type WinJSContrib.UI.MultiPassRenderer
                 */
            	grid.renderer = new WinJSContrib.UI.MultiPassRenderer(grid.element, {
            		multipass: options.multipass,
            		itemClassName: options.itemClassName,
            		itemTemplate: options.itemTemplate,
            		itemInvoked: options.itemInvoked,
            	});

            	/**
                 * layout definitions for the grid. It's an object containing several grid layout options. See {@link WinJSContrib.UI.GridControlLayout}
                 * @field
                 * @type Object
                 */
            	grid.gridLayouts = options.layouts;

            	/**
                 * default layout definitions for the grid
                 * @field
                 * @type WinJSContrib.UI.GridControlLayout
                 */
            	grid.defaultLayout = {
            		layout: 'horizontal',
            		itemsPerColumn: (options.itemsPerColumn) ? options.itemsPerColumn : undefined,
            		itemsPerRow: (options.itemsPerRow) ? options.itemsPerRow : undefined,
            		cellSpace: (options.cellSpace) ? options.cellSpace : 10,
            		cellWidth: (options.cellWidth) ? options.cellWidth : undefined,
            		cellHeight: (options.cellHeight) ? options.cellHeight : undefined,
            	};
            },
            /**
             * @lends WinJSContrib.UI.GridControl.prototype
             */
            {
            	/**
                 * scroll element containing the grid. Required for multi pass rendering
                 * @field
                 * @type HTMLElement
                 */
            	scrollContainer: {
            		get: function () {
            			return this.renderer.scrollContainer;
            		},
            		set: function (val) {
            			this.renderer.scrollContainer = val;
            		}
            	},

            	/**
                 * callback triggered when clicking on an item
                 * @field
                 * @type HTMLElement
                 */
            	itemInvoked: {
            		get: function () {
            			return this.renderer.itemInvoked;
            		},
            		set: function (val) {
            			this.renderer.itemInvoked = val;
            		}
            	},

            	/**
                 * item template (WinJS Template or template function)
                 * @field
                 * @type Object
                 */
            	itemTemplate: {
            		get: function () {
            			return this.renderer.itemTemplate;
            		},
            		set: function (val) {
            			this.renderer.itemTemplate = val;
            		}
            	},

            	/**
                 * css class added on item's placeholder
                 * @field
                 * @type Object
                 */
            	itemClassName: {
            		get: function () {
            			return this.renderer.itemClassName;
            		},
            		set: function (val) {
            			this.renderer.itemClassName = val;
            		}
            	},

            	/**
                 * render HTML for items
                 * @param {Array} items array of items to render
                 * @param {Object} renderOptions
                 */
            	prepareItems: function (items, renderOptions) {
            		var parent = WinJSContrib.Utils.getParentControlByClass('mcn-layout-ctrl', this.element);
            		var parentMultipass = undefined;
            		if (!this.renderer.multipass &amp;&amp; parent &amp;&amp; parent.multipass) {
            			this.renderer.multipass = parent.multipass;
            		}

            		this.renderer.prepareItems(items, renderOptions);
            	},

            	pageLayout: function () {
            		this.renderer.pageLayout();
            		if (this.autolayout) {
            			this.layout();
            		}
            	},

            	/**
                 * force items content to render
                 */
            	renderItemsContent: function () {
            		this.renderer.renderItemsContent();
            	},

            	resetElement: function (elt) {
            		if (elt.style.position) elt.style.position = '';
            		if (elt.style.display) elt.style.display = '';
            		if (elt.style.width) elt.style.width = '';
            		if (elt.style.height) elt.style.height = '';
            		if (elt.style.minWidth) elt.style.minWidth = '';
            		if (elt.style.minHeight) elt.style.minHeight = '';
            		if (elt.style.left) elt.style.left = '';
            		if (elt.style.top) elt.style.top = '';
            	},

            	/**
                 * Clear all layout and position styles on items
                 */
            	clear: function () {
            		var ctrl = this;
            		ctrl.resetElement(ctrl.element);
            		if (ctrl.element.children.length) {
            			for (var i = 0, l = ctrl.element.children.length; i &lt; l; i++) {
            				ctrl.resetElement(ctrl.element.children[i]);
            			}
            		}
            	},

            	fill: function (matrix, x, y, w, h) {
            		if (matrix.length &lt; x + w) {
            			for (var i = matrix.length ; i &lt; x + w ; i++) {
            				matrix.push([]);
            			}
            		}

            		for (var i = x ; i &lt; x + w ; i++) {
            			var col = matrix[i];
            			if (col.length &lt; y + h) {
            				for (var j = col.length ; j &lt; y + h ; j++) {
            					col.push(false);
            				}
            			}

            			for (var j = y ; j &lt; y + h ; j++) {
            				col[j] = true;
            			}
            		}
            	},

            	fit: function (matrix, x, y, w, h, maxW, maxH) {
            		//items to big
            		if (maxH &amp;&amp; h > maxH &amp;&amp; y === 0)
            			return true;
            		if (maxW &amp;&amp; w > maxW &amp;&amp; x === 0)
            			return true;

            		//overflow grid capacity
            		if (maxW &amp;&amp; (x + w) > maxW)
            			return false;
            		if (maxH &amp;&amp; (y + h) > maxH)
            			return false;

            		for (var i = x ; i &lt; x + w ; i++) {
            			var col = matrix[i];
            			if (col) {
            				for (var j = y ; j &lt; y + h ; j++) {
            					if (col[j] === true)
            						return false;
            				}
            			}
            		}

            		return true;
            	},

            	firstFit: function (matrix, w, h, maxH, numItems) {
            		var ctrl = this;
            		for (var i = 0 ; i &lt; numItems * maxH * 2 ; i++) {
            			var col = matrix[i];
            			if (col) {
            				for (var j = 0 ; j &lt; maxH ; j++) {
            					if (col[j] !== true &amp;&amp; ctrl.fit(matrix, i, j, w, h, undefined, maxH)) {
            						return { x: i, y: j };
            					}
            				}
            			}
            			else {
            				return { x: i, y: 0 };
            			}
            		}

            		return undefined;
            	},

            	visibleChilds: function () {
            		var ctrl = this;
            		var res = [];

            		for (var i = 0, l = ctrl.element.children.length; i &lt; l ; i++) {
            			var item = ctrl.element.children[i];
            			var st = window.getComputedStyle(item);
            			if (st.display != 'none' &amp;&amp; st.visibility != 'hidden') {
            				res.push(item);
            			}
            		}

            		return res;
            	},

            	/**
                 * Layouts algorythm implementations
                 */
            	GridLayoutsImpl: {
            		none: function () {
            		},

            		flexhorizontal: function () {
            			var ctrl = this;
            			ctrl.renderer.orientation = 'horizontal';
            			ctrl.element.style.position = 'relative';
            			ctrl.element.style.display = 'flex';
            			ctrl.element.style.flexFlow = 'column wrap';
            			ctrl.element.style.alignContent = 'flex-start';
            			//ctrl.element.style.alignContent = 'flex-start';

            			if (ctrl.element.style.width)
            				ctrl.element.style.width = '';

            			ctrl.element.style.height = '';

            			if (ctrl.element.clientHeight)
            				ctrl.element.style.height = ctrl.element.clientHeight + 'px';
            			else
            				ctrl.element.style.height = '';

            			var _itemsPerColumn = Math.floor(ctrl.element.clientHeight / (ctrl.data.cellHeight + ctrl.data.cellSpace));
            			if (_itemsPerColumn) {
            				var visibleitems = ctrl.visibleChilds();
            				var columns = Math.ceil(visibleitems.length / _itemsPerColumn);
            				ctrl.element.style.minWidth = ((ctrl.data.cellWidth + ctrl.data.cellSpace) * columns) + 'px';
            			}
            		},

            		flexvertical: function () {
            			var ctrl = this;
            			ctrl.renderer.orientation = 'vertical';
            			ctrl.element.style.position = 'relative';
            			ctrl.element.style.display = 'flex';
            			ctrl.element.style.flexFlow = 'row wrap';
            			ctrl.element.style.alignContent = 'flex-start';

            			ctrl.element.style.width = '';
            			if (ctrl.element.clientWidth)
            				ctrl.element.style.width = ctrl.element.clientWidth + 'px';
            			else
            				ctrl.element.style.width = '';

            			if (ctrl.element.style.height)
            				ctrl.element.style.height = '';
            		},

            		hbloc: function () {
            			var ctrl = this;
            			ctrl.renderer.orientation = 'horizontal';
            			ctrl.element.style.position = 'relative';
            			ctrl.element.style.height = '';
            			var _containerH = ctrl.element.clientHeight;
            			if (!_containerH)
            				return;

            			var cellW = ctrl.data.cellWidth;
            			var space = ctrl.data.cellSpace;
            			var colCount = 1;
            			var colOffset = 0;
            			var topOffset = 0;

            			var childs = ctrl.visibleChilds();
            			childs.forEach(function (elt) {
            				if (elt.style.position != 'absolute')
            					elt.style.position = 'absolute';
            				var eltH = elt.clientHeight;
            				if (topOffset + eltH > _containerH) {
            					colCount++;
            					colOffset = colOffset + space + cellW;
            					topOffset = 0;
            				}

            				if (elt.style.left != colOffset + 'px')
            					elt.style.left = colOffset + 'px';
            				if (elt.style.top != topOffset + 'px')
            					elt.style.top = topOffset + 'px';

            				topOffset += eltH;
            			});

            			colOffset = colOffset + cellW;
            			if (ctrl.element.style.width != colOffset + 'px')
            				ctrl.element.style.width = colOffset + 'px';
            		},

            		horizontal: function () {
            			var ctrl = this;
            			ctrl.renderer.orientation = 'horizontal';
            			ctrl.element.style.position = 'relative';
            			ctrl.element.style.height = '';
            			var _containerH = ctrl.element.clientHeight;
            			if (!_containerH)
            				return;

            			var _itemsPerColumn = Math.floor(_containerH / (ctrl.data.cellHeight + ctrl.data.cellSpace));
            			if (_itemsPerColumn &lt;= 0)
            				_itemsPerColumn = 1;

            			var cellW = ctrl.data.cellWidth;
            			var cellH = ctrl.data.cellHeight;
            			var space = ctrl.data.cellSpace;
            			var aspectRatio = cellW / cellH;
            			var ratioW = 1;
            			var ratioH = 1;

            			if (ctrl.data.itemsPerColumn) {
            				_itemsPerColumn = ctrl.data.itemsPerColumn;
            				cellH = ((_containerH - ((_itemsPerColumn - 1) * space)) / _itemsPerColumn) >> 0;
            				cellW = (ctrl.data.cellWidth * cellH / ctrl.data.cellHeight) >> 0;
            				ratioW = cellW / ctrl.data.cellWidth;
            				ratioH = cellH / ctrl.data.cellHeight;
            			}

            			var gridCellsMatrix = [[]];
            			var childs = ctrl.visibleChilds();
            			childs.forEach(function (elt) {
            				elt.style.position = 'absolute';
            				var eltW = elt.clientWidth * ratioW;
            				var eltH = elt.clientHeight * ratioH;
            				var eltColumns = (eltW / cellW) >> 0;
            				var eltRows = (eltH / cellH) >> 0;

            				var pos = ctrl.firstFit(gridCellsMatrix, eltColumns, eltRows, _itemsPerColumn, ctrl.element.children.length);
            				if (!pos)
            					pos = { x: 0, y: 0 };
            				ctrl.fill(gridCellsMatrix, pos.x, pos.y, eltColumns, eltRows);

            				var left = pos.x * (cellW + space);
            				var top = pos.y * (cellH + space);
            				var w = (eltColumns * cellW + ((eltColumns - 1) * space));
            				var h = (eltRows * cellH + ((eltRows - 1) * space));
            				elt.style.left = left + 'px';
            				elt.style.top = top + 'px';
            				elt.style.width = w + 'px';
            				elt.style.height = h + 'px';
            			});

            			var elementWidth = gridCellsMatrix.length * (cellW + space);
            			ctrl.element.style.width = elementWidth + 'px';
            		},

            		vertical: function (plugin) {
            			var ctrl = this;
            			ctrl.renderer.orientation = 'vertical';
            			ctrl.element.style.width = '';
            			ctrl.element.style.position = 'relative';
            			//Be aware that in this case, we invert the matrix to crawl data in lines
            			var _containerW = ctrl.element.clientWidth;
            			if (!_containerW)
            				return;

            			var _itemsPerLine = Math.floor(_containerW / (ctrl.data.cellWidth + ctrl.data.cellSpace));
            			if (_itemsPerLine &lt;= 0)
            				_itemsPerLine = 1;

            			var cellW = ctrl.data.cellWidth;
            			var cellH = ctrl.data.cellHeight;
            			var space = ctrl.data.cellSpace;
            			var aspectRatio = cellW / cellH;
            			var ratioW = 1;
            			var ratioH = 1;

            			if (ctrl.data.itemsPerRow) {
            				_itemsPerLine = ctrl.data.itemsPerRow;
            				cellW = ((_containerW - ((_itemsPerLine - 1) * space)) / _itemsPerLine) >> 0;
            				cellH = (ctrl.data.cellHeight * cellW / ctrl.data.cellWidth) >> 0;
            				ratioW = cellW / ctrl.data.cellWidth;
            				ratioH = cellH / ctrl.data.cellHeight;
            			}

            			var gridCellsMatrix = [[]];
            			var childs = ctrl.visibleChilds();
            			childs.forEach(function (elt) {
            					elt.style.position = 'absolute';
            					
            					var eltW = elt.clientWidth * ratioW;
            					var eltH = elt.clientHeight * ratioH;
            					var eltColumns = (eltW / cellW) >> 0;
            					var eltRows = (eltH / cellH) >> 0;

            					var pos = ctrl.firstFit(gridCellsMatrix, eltRows, eltColumns, _itemsPerLine, ctrl.element.children.length);
            					//if (!pos)
            					//    return;

            					ctrl.fill(gridCellsMatrix, pos.x, pos.y, eltRows, eltColumns);

            					var left = pos.y * (cellW + space);
            					var top = pos.x * (cellH + space);
            					elt.style.left = left + 'px';
            					elt.style.top = top + 'px';
            					elt.style.width = (eltColumns * cellW + ((eltColumns - 1) * space)) + 'px';
            					elt.style.height = (eltRows * cellH + ((eltRows - 1) * space)) + 'px';
            				
            			});

            			var elementHeight = gridCellsMatrix.length * (cellH + space);
            			ctrl.element.style.height = elementHeight + 'px';
            		},
            	},

            	/**
                 * layout content items
                 */
            	layout: function () {
            		var ctrl = this;
            		var oldlayout = ctrl.data;
            		ctrl.data = ctrl.getLayout();

            		if (ctrl.data) {
            			//if (ctrl.data == oldlayout &amp;&amp; ctrl.data.applyed)
            			//    return;

            			ctrl.data.cellSpace = (ctrl.data.cellSpace != undefined ? ctrl.data.cellSpace : (ctrl.defaultLayout.cellSpace != undefined ? ctrl.defaultLayout.cellSpace : 10));
            			ctrl.data.cellWidth = ctrl.data.cellWidth || ctrl.defaultLayout.cellWidth || 0;
            			ctrl.data.cellHeight = ctrl.data.cellHeight || ctrl.defaultLayout.cellHeight || 0;

            			//if cell dimensions are not defined, take it from last child
            			if (!ctrl.data.cellWidth || !ctrl.data.cellHeight) {
            				if (ctrl.element.childNodes &amp;&amp; ctrl.element.children.length > 0) {
            					var firstChild = ctrl.element.children[0];
            					ctrl.data.cellWidth = firstChild.clientWidth;
            					ctrl.data.cellHeight = firstChild.clientHeight;
            				}
            			}

            			var layoutChanged = !oldlayout || ctrl.data.layout !== oldlayout.layout;
            			var layoutfunc = ctrl.GridLayoutsImpl[ctrl.data.layout.toLowerCase()];
            			if (layoutfunc) {
            				if (layoutChanged)
            					ctrl.changeLayout();

            				layoutfunc.bind(ctrl)(layoutChanged);
            				ctrl.data.applyed = true;
            			}

            			ctrl.renderer.checkRendering();
            		}
            	},

            	changeLayout: function () {
            		var ctrl = this;
            		ctrl.clear();
            		ctrl.renderer.updateLayout();
            	},

            	/**
                 * update grid layout
                 */
            	updateLayout: function (element, viewState, lastViewState) {
            		var ctrl = this;
            		ctrl.layout();
            	},

            	/**
                 * get layout applicable to the current context
                 */
            	getLayout: function () {
            		var ctrl = this;
            		var matchingLayout = undefined;
            		if (ctrl.gridLayouts) {
            			for (var name in ctrl.gridLayouts) {
            				var layout = ctrl.gridLayouts[name];
            				if (ctrl.gridLayouts.hasOwnProperty(name)) {
            					if (layout.query) {
            						var mq = window.matchMedia(layout.query);
            						if (mq.matches) {
            							matchingLayout = layout;
            						}
            					} else if (!matchingLayout) {
            						matchingLayout = layout;
            					}
            				}
            				else if (!matchingLayout) {
            					matchingLayout = layout;
            				}
            			}
            		}

            		if (!matchingLayout) {
            			matchingLayout = ctrl.defaultLayout;
            		}

            		return JSON.parse(JSON.stringify(matchingLayout));
            	},

            	/**
                 * Release grid resources
                 */
            	dispose: function () {
            		if (WinJS.Utilities.disposeSubTree)
            			WinJS.Utilities.disposeSubTree(this.element);
            	}
            })
	});
})();</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					by MCNEXT
					<br />
					
					
		<span class="copyright">
		copyright MCNEXT
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on Sun Apr 05 2015 23:50:42 GMT+0200 (Romance Daylight Time) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
