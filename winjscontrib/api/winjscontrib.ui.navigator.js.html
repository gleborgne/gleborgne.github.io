<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>WinJS Contrib Source: winjscontrib.ui.navigator.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">WinJS Contrib</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="global.html#WinJSContrib">WinJSContrib</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Alerts.html">Alerts</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Bindings.html">Bindings</a>
						</li>
						
						<li>
							<a href="WinJSContrib.CrossPlatform.html">CrossPlatform</a>
						</li>
						
						<li>
							<a href="WinJSContrib.CrossPlatform.isMobile.html">isMobile</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.html">Logging</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.Appenders.html">Appenders</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.html">Search</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.html">Stemming</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.Op.html">Op</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.StopWords.html">StopWords</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Templates.html">Templates</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.html">UI</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.Animation.html">Animation</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataForm.Converters.html">Converters</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.html">DataSources</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.Grouping.html">Grouping</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Utils.html">Utils</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Utils.ValueParsers.html">ValueParsers</a>
						</li>
						
						<li>
							<a href="WinJSContrib.WinRT.html">WinRT</a>
						</li>
						

					</ul>
				</li>
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="WinJSContrib.Logging.Appenders.ConsoleAppender.html">ConsoleAppender</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Logging.LoggerClass.html">LoggerClass</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Messenger.html">Messenger</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Messenger.SmartWorker.html">SmartWorker</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Index.html">Index</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.IndexGroup.html">IndexGroup</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.IndexWorkerProxy.html">IndexWorkerProxy</a>
						</li>
						
						<li>
							<a href="WinJSContrib.Search.Stemming.Pipeline.html">Pipeline</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.ChildViewFlyout.html">ChildViewFlyout</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataForm.html">DataForm</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.DataSources.DataSourceManager.html">DataSourceManager</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.EventTracker.html">EventTracker</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.ExtendedSplash.html">ExtendedSplash</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FlipSnap.html">FlipSnap</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FlipViewPager.html">FlipViewPager</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FluentDOM.html">FluentDOM</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.FlyoutPage.html">FlyoutPage</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.GlobalProgress.html">GlobalProgress</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.GridControl.html">GridControl</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.HubControl.html">HubControl</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MediaTrigger.html">MediaTrigger</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MultiPassItem.html">MultiPassItem</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.MultiPassRenderer.html">MultiPassRenderer</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.PageControlNavigator.html">PageControlNavigator</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.SemanticListViews.html">SemanticListViews</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UI.SmartListLayout.html">SmartListLayout</a>
						</li>
						
						<li>
							<a href="WinJSContrib.UPnP.UPnPDevice.html">UPnPDevice</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: winjscontrib.ui.navigator.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">/* 
 * WinJS Contrib v2.1.0.0
 * licensed under MIT license (see http://opensource.org/licenses/MIT)
 * sources available at https://github.com/gleborgne/winjscontrib
 */

/// &lt;reference path="WinJSContrib.core.js" />

(function () {
	"use strict";

	var appView = null;
	if (window.Windows &amp;&amp; window.Windows.UI &amp;&amp; window.Windows.UI.ViewManagement &amp;&amp; window.Windows.UI.ViewManagement.ApplicationView)
		appView = window.Windows.UI.ViewManagement.ApplicationView;

	var nav = WinJS.Navigation;

	var defaultExitPageAnimation = function (elt) {
		return WinJS.UI.Animation.exitPage(elt)
	}

	var defaultEnterPageAnimation = function (elt) {
		return WinJS.UI.Animation.enterPage(elt);
	}

	WinJS.Namespace.define("WinJSContrib.UI", {
		parentNavigator: function (element) {
			var current = element.parentNode;

			while (current) {
				if (current.mcnNavigator) {
					return current.winControl;
				}
				current = current.parentNode;
			}
		},

		PageControlNavigator: WinJS.Class.mix(WinJS.Class.define(
            /**
             * @class WinJSContrib.UI.PageControlNavigator
             * @param {HTMLElement} element DOM element containing the control
             * @param {Object} options
             */
            function PageControlNavigator(element, options) {
            	var options = options || {};
            	var navigator = this;
            	this.element = element || document.createElement("div");
            	this.element.winControl = this;
            	this.element.mcnNavigator = true;
            	this.element.classList.add('mcn-navigator');
            	this.element.classList.add('mcn-navigation-ctrl');
            	this.eventTracker = new WinJSContrib.UI.EventTracker();
            	this.delay = options.delay || 0;
            	this.disableHistory = options.disableHistory || false;
            	this.animationWaitForPreviousPageClose = options.animationWaitForPreviousPageClose || true;
            	this.animations = {};
            	this.locks = 0;

            	if (options.enterPageAnimation) {
            		this.animations.enterPage = WinJSContrib.Utils.resolveMethod(element, options.enterPageAnimation);
            	}
            	if (!this.animations.enterPage)
            		this.animations.enterPage = defaultEnterPageAnimation;

            	if (options.exitPageAnimation) {
            		this.animations.exitPage = WinJSContrib.Utils.resolveMethod(element, options.exitPageAnimation);
            	}
            	if (!this.animations.exitPage)
            		this.animations.exitPage = defaultExitPageAnimation;

            	this.home = options.home;
            	if (appView)
            		this._lastViewstate = appView.value;

            	this.global = options.global !== undefined ? options.global : true;
            	if (this.global) { //navigation classique 
            		document.body.onkeyup = this._keyupHandler.bind(this);
            		document.body.onkeypress = this._keypressHandler.bind(this);
            		document.body.onmspointerup = this._mspointerupHandler.bind(this);

            		WinJSContrib.UI.Application = WinJSContrib.UI.Application || {};
            		WinJSContrib.UI.Application.navigator = this;

            		this.eventTracker.addEvent(nav, 'beforenavigate', this._beforeNavigate.bind(this));
            		this.eventTracker.addEvent(nav, 'navigated', this._navigated.bind(this));
            	}
            	else {
            		if (options.navigationEvents) {
            			this.addNavigationEvents();
            		}
            		this._history = { backstack: [] };
            	}

            	this.eventTracker.addEvent(window, 'resize', function (args) {
            		if (navigator.resizeHandler)
            			cancelAnimationFrame(navigator.resizeHandler);

            		navigator.resizeHandler = requestAnimationFrame(function () {
            			navigator.resizeHandler = null;
            			navigator._resized(args);
            		});
            	});
            },
            /**
             * @lends WinJSContrib.UI.PageControlNavigator.prototype
             */
            {
            	home: "",
            	/// &lt;field domElement="true" />
            	element: null,
            	_lastNavigationPromise: WinJS.Promise.as(),
            	_lastViewstate: 0,

            	// This is the currently loaded Page object.
            	pageControl: {
            		get: function () {
            			return this.pageElement ? this.pageElement.winControl : null;
            		}
            	},

            	// This is the root element of the current page.
            	pageElement: {
            		get: function () {
            			return this._pageElement || this.element.lastElementChild;
            		}
            	},

            	history : {
            		get: function(){
            			if (this.global)
            				return WinJS.Navigation.history;
            			else
            				return this._history;
            		}
            	},

            	addLock: function () {
            		this.locks++;
            	},

            	removeLock: function () {
            		this.locks--;
            	},

            	// Creates a container for a new page to be loaded into.
            	_createPageElement: function () {
            		var element = document.createElement("div");
            		element.setAttribute("dir", window.getComputedStyle(this.element, null).direction);
            		//element.style.width = "100%";
            		//element.style.height = "100%";
            		//element.style.position = 'relative';
            		return element;
            	},

            	// This function disposes the page navigator and its contents.
            	dispose: function () {
            		if (this._disposed) {
            			return;
            		}
            		this._disposed = true;
            		this.removeNavigationEvents();
            		if (WinJS.Utilities.disposeSubTree)
            			WinJS.Utilities.disposeSubTree(this.element);

            		this.eventTracker.dispose();
            	},

				//check back navigation in the context of navigation events.
            	_checkBackNavigation: function (arg) {
            		var navigator = this;
            		var currentPage = navigator.pageControl;
            		var confirm = function () {
            			arg.handled = true;
            			if (arg.preventDefault)
            				arg.preventDefault();
            		}
            		var check = function () {
            			if (navigator.canGoBack) {
            				navigator.back();
            				confirm();
            				return true;
            			};
            		}

            		if (currentPage.canClose) {
            			var res = currentPage.canClose();
            			if (WinJS.Promise.is(res)) {
            				res.then(function (canClose) {
            					if (!canClose) {
            						confirm();
            						return true;
            					}
            					return check();
            				});
            			} else {
            				if (!res) {
            					confirm();
            					return true;
            				}
            				return check();
            			}

            		} else {
            			return check();
            		}
            	},

				//register hardware backbutton. unecessary if navigator is global
            	addNavigationEvents: function () {
            		var navigator = this;
            		this.navigationEvents = WinJSContrib.UI.registerNavigationEvents(this, function (arg) {
            			navigator._checkBackNavigation(arg);
            		});
            	},

            	removeNavigationEvents: function(){
            		if (this.navigationEvents){
            			this.navigationEvents();
            			this.navigationEvents = null;
            		}
            	},

            	// Retrieves a list of animation elements for the current page.
            	// If the page does not define a list, animate the entire page.
            	_getAnimationElements: function (isExit) {
            		if (this.pageControl &amp;&amp; this.pageControl.getAnimationElements) {
            			return this.pageControl.getAnimationElements(isExit);
            		}
            		return this.pageElement;
            	},

            	// Navigates back whenever the backspace key is pressed and
            	// not captured by an input field.
            	_keypressHandler: function (args) {
            		if (this.locks > 0)
            			return;

            		if (args.key === "Backspace") {
            			this.back();
            		}
            	},

            	// Navigates back or forward when alt + left or alt + right
            	// key combinations are pressed.
            	_keyupHandler: function (args) {
            		if (this.locks > 0)
            			return;

            		if ((args.key === "Left" &amp;&amp; args.altKey) || (args.key === "BrowserBack")) {
            			this.back();
            		}/* else if ((args.key === "Right" &amp;&amp; args.altKey) || (args.key === "BrowserForward")) {
            			nav.forward();
            		}*/
            	},

            	// This function responds to clicks to enable navigation using
            	// back and forward mouse buttons.
            	_mspointerupHandler: function (args) {
            		if (args.button === 3) {
            			nav.back();
            		} else if (args.button === 4) {
            			nav.forward();
            		}
            	},

            	navigate: function (location, initialState, skipHistory, isback) {
            		var nav = this;
            		if (this.global) {
            			return WinJS.Navigation.navigate(location, initialState);
            		} else {
            			var arg = {
            				skipHistory: skipHistory,
            				detail: {
            					location: location,
            					state: initialState,
            					setPromise: function (promise) {
            						this.pagePromise = promise;
            					}
            				}
            			};
            			nav._beforeNavigate(arg);
            			arg.detail.pagePromise = arg.detail.pagePromise || WinJS.Promise.wrap();
            			nav._history.current = { state: initialState, location: location };
            			return arg.detail.pagePromise.then(function () {
            				if (isback) {
            					nav._history.backstack.splice(nav._history.backstack.length - 1, 1);
            				}
            				nav._navigated(arg);
            				return arg.detail.pagePromise;
            			});
            		}
            	},

            	clearHistory: function () {
            		if (this.global) {
            			WinJS.Navigation.history.backStack = [];
            		} else {
            			this._history.backstack = [];
            			this._history.current = null;
            		}
            	},

            	closeAllPages: function () {
            		var navigator = this;
            		var pages = navigator.element.querySelectorAll('.pagecontrol');
            		for (var i = 0, l = pages.length ; i &lt; l ; i++) {
            			var page = pages[i];
            			if (page.parentElement == navigator.element) {
            				page.winControl.dispose();
            				navigator.element.removeChild(page);
            			}
            		}
            	},

            	clear: function () {
            		this.clearHistory();
            		this.closeAllPages();
            		this._pageElement = null;
            		this.element.innerHTML = '';
            	},

            	//warning, deprecated...
            	open: function (uri, options) {
            		return this.navigate(uri, options);
            	},

            	pick: function (uri, options) {
            		options = options || {};
            		options.navigateStacked = true;
            		return this.navigate(uri, options);
            	},

            	canGoBack: {
            		get: function () {
            			if (this.global)
            				return nav.canGoBack;
            			else
            				return this._history.backstack.length > 0;
            		}
            	},

            	back: function (distance) {
            		var navigator = this;
            		if (navigator.global) {
            			return WinJS.Navigation.back(distance);
            		}
            		else {
            			if (navigator._history.backstack.length) {
            				var pageindex = navigator._history.backstack.length - 1;
            				var previousPage = navigator._history.backstack[pageindex];

            				return navigator.navigate(previousPage.location, previousPage.state, true, true);
            			}
            		}
            	},

            	_beforeNavigate: function (args) {
            		var navigator = this;
            		var page = this.pageElement;
            		args.detail.state = args.detail.state || {};
            		var openStacked = navigator.stackNavigation == true || args.detail.state.navigateStacked;

            		if (this.locks > 0) {
            			var p = new WinJS.Promise(function (c) { });
            			args.detail.setPromise(p);
            			p.cancel();
            			return;
            		}
            		else if (page &amp;&amp; page.winControl &amp;&amp; page.winControl.canClose) {
            			var completeCallback = null;
            			var p = new WinJS.Promise(function (c) {
            				completeCallback = c;
            			});
            			setImmediate(function () {
            				WinJS.Promise.wrap(page.winControl.canClose()).then(function (res) {
            					if (!res) {
            						p.cancel();
            					}
            					else {
            						navigator.triggerPageExit();
            						completeCallback();
            					}
            				});
            			});
            			args.detail.setPromise(p);

            			return;
            		}

            		if (openStacked &amp;&amp; !args.detail.state.mcnNavigationDetails)
            			return;

            		navigator.triggerPageExit();
            	},

            	triggerPageExit: function () {
            		var navigator = this;
            		var page = this.pageElement;
            		var hidepage = function () {
            			page.style.display = 'none';
            			page.style.visibility = 'hidden';
            			page.style.opacity = '';
            		}

            		if (page &amp;&amp; page.winControl &amp;&amp; !page.winControl.exitPagePromise) {
            			if (page.winControl.exitPage) {
            				var exitPageResult = page.winControl.exitPage();
            				if (exitPageResult) {
            					var res = WinJS.Promise.as(exitPageResult);
            					page.winControl.exitPagePromise = res.then(function () {
            						if (page.winControl.exitPageAnimation) {
            							return WinJS.Promise.as(page.winControl.exitPageAnimation());
            						}
            					}).then(hidepage);
            				} else {
            					if (page.winControl.exitPageAnimation) {
            						page.winControl.exitPagePromise = WinJS.Promise.as(page.winControl.exitPageAnimation()).then(hidepage);
            					} else {
            						page.winControl.exitPagePromise = WinJS.Promise.as(navigator.animations.exitPage(navigator._getAnimationElements(true))).then(hidepage);
            					}
            				}
            			} else {
            				if (page.winControl.exitPageAnimation) {
            					page.winControl.exitPagePromise = WinJS.Promise.as(page.winControl.exitPageAnimation()).then(hidepage);
            				} else {
            					page.winControl.exitPagePromise = WinJS.Promise.as(navigator.animations.exitPage(navigator._getAnimationElements(true))).then(hidepage);
            				}
            			}

            			var layoutCtrls = page.querySelectorAll('.mcn-layout-ctrl');
            			if (layoutCtrls &amp;&amp; layoutCtrls.length) {
            				for (var i = 0 ; i &lt; layoutCtrls.length; i++) {
            					var ctrl = layoutCtrls[i].winControl;
            					if (ctrl.exitPage)
            						ctrl.exitPage();
            				}
            			}

            			if (WinJSContrib.UI.Application.progress)
            				WinJSContrib.UI.Application.progress.show();
            		}
            	},

            	closePage: function (pageElementToClose, args) {
            		var navigator = this;
            		args = args || {};
            		var pagecontainer = navigator.element;
            		var oldElement = pageElementToClose || this.pageElement;
            		if (oldElement) {
            			WinJSContrib.UI.untapAll(oldElement);
            		}
            		var oldPageExitPromise = (oldElement &amp;&amp; oldElement.winControl &amp;&amp; oldElement.winControl.exitPagePromise) ? oldElement.winControl.exitPagePromise : WinJS.Promise.wrap()
            		navigator.dispatchEvent('closingPage', { page: oldElement });

            		if (oldElement &amp;&amp; oldElement.winControl) {
            			oldElement.winControl.pageLifeCycle.stop();
            			oldElement.winControl.dispatchEvent('closing', { youpla: 'boom' });

            			if (oldElement.winControl.cancelPromises) {
            				oldElement.winControl.cancelPromises();
            			}
            		}

            		if (!navigator.global &amp;&amp; !navigator.disableHistory &amp;&amp; oldElement &amp;&amp; oldElement.winControl &amp;&amp; oldElement.winControl.navigationState &amp;&amp; !args.skipHistory) {
            			navigator._history.backstack.push(oldElement.winControl.navigationState);
            		}

            		navigator._pageElement = null;
            		return oldPageExitPromise.then(function () {
            			if (oldElement) {
            				oldElement.style.opacity = '0';
            				oldElement.style.display = 'none';
            				//    }
            				//    return WinJS.Promise.timeout();
            				//}).then(function () {
            				//    if (oldElement) {
            				if (oldElement.winControl) {
            					oldElement.winControl.stackedOn = null;
            					oldElement.winControl.stackedBy = null;
            					if (oldElement.winControl.eventTracker) {
            						oldElement.winControl.eventTracker.dispose();
            					}

            					if (oldElement.winControl.unload) {
            						oldElement.winControl.unload();
            					}
            				}

            				if (WinJS.Utilities.disposeSubTree)
            					WinJS.Utilities.disposeSubTree(oldElement);

            				//oldElement.innerHTML = '';
            				//setImmediate(function () {
            				try {
            					oldElement.parentElement.removeChild(oldElement);
            				}
            				catch (exception) {
            					console.log('cannot remove page, WTF ????????')
            				}
            				//});
            			}
            		});
            	},

            	// Responds to navigation by adding new pages to the DOM.
            	_navigated: function (args) {
            		var navigator = this;
            		args.detail.state = args.detail.state || {};
            		var pagecontainer = navigator.element;
            		var oldPage = this.pageControl;
            		var oldElement = this.pageElement;
            		var openStacked = navigator.stackNavigation == true || (args.detail.state &amp;&amp; args.detail.state.navigateStacked);

            		if (this._lastNavigationPromise) {
            			this._lastNavigationPromise.cancel();

            			if (WinJSContrib.UI.Application.progress)
            				WinJSContrib.UI.Application.progress.hide();
            		}

            		if (oldPage &amp;&amp; oldPage.stackedOn &amp;&amp; args.detail.state.mcnNavigationDetails) {//back en nav stacked
            			var closeOldPagePromise = navigator.closePage(oldElement, args);
            			this._lastNavigationPromise = closeOldPagePromise;
            			args.detail.setPromise(closeOldPagePromise);
            			if (WinJSContrib.UI.Application.progress)
            				WinJSContrib.UI.Application.progress.hide();
            			return;
            		}
            		else if (openStacked) {
            			if (!navigator.global &amp;&amp; !navigator.disableHistory &amp;&amp; oldElement &amp;&amp; oldElement.winControl &amp;&amp; oldElement.winControl.navigationState &amp;&amp; !args.skipHistory) {
            				navigator._history.backstack.push(oldElement.winControl.navigationState);
            			}
            			var closeOldPagePromise = WinJS.Promise.wrap();
            		}
            		else {
            			var closeOldPagePromise = navigator.closePage(oldElement, args);
            		}

            		args.detail.state.mcnNavigationDetails = {
            			id: WinJSContrib.Utils.guid(),
            			date: new Date()
            		};

            		//var newElement = null; //this._createPageElement();
            		//var newElementCtrl = null;
            		var parentedComplete;
            		var parented = new WinJS.Promise(function (c) { parentedComplete = c; });
            		//newElement.style.opacity = '0';
            		var layoutCtrls = [];


            		//if (navigator.animationWaitForPreviousPageClose) {
            		//    var tempo = closeOldPagePromise.then(function () {
            		//        return WinJS.Promise.timeout(navigator.delay);
            		//    });
            		//} else {
            		//    var tempo = WinJS.Promise.timeout(navigator.delay);
            		//}

            		navigator.currentPageDetails = args.detail;

            		var openNewPagePromise = WinJSContrib.UI.Pages.renderFragment(pagecontainer, args.detail.location, args.detail.state, {
            			//delay: tempo,
            			enterPage: navigator.animations.enterPage,

            			//parented: closeOldPagePromise.then(function () {
            			//	return parented;
            			//}),

            			closeOldPagePromise: closeOldPagePromise.then(function () { }, function () { }),

            			oninit: function (element, options) {
            				if (!element) return;
            				var control = element.winControl;
            				control.navigator = navigator;
            				control.element.mcnPage = true;
            				if (openStacked) {
            					control.stackedOn = oldPage;
            					if (oldPage) {
            						oldPage.stackedBy = control;
            					}
            				}
            				control.renderComplete = control.renderComplete.then(function () {
            					parentedComplete();
            				});
            			},

            			onrender: function (element, options) {
            				if (args.detail.state &amp;&amp; args.detail.state.clearNavigationHistory) {
            					if (navigator.global) {
            						WinJS.Navigation.history.backStack = [];
            					} else {
            						navigator._history.backstack = [];
            					}
            				}
            				navigator._updateBackButton(element);
            			},

            			onready: function (element, options) {
            				navigator.dispatchEvent('pageContentReady', { page: element.winControl });
            				if (WinJSContrib.UI.Application.progress)
            					WinJSContrib.UI.Application.progress.hide();
            			}
            		}).then(function () {
            			navigator._lastNavigationPromise = undefined;
            		});

            		this._lastNavigationPromise = openNewPagePromise;


            		args.detail.setPromise(WinJS.Promise.join([closeOldPagePromise, openNewPagePromise]));
            	},

            	// Responds to resize events and call the updateLayout function
            	// on the currently loaded page.
            	_resized: function (args) {
            		var navigator = this;
            		if (this.pageControl &amp;&amp; this.pageControl.element) {
            			var navigator = this;
            			var control = this.pageControl;
            			var element = control.element;

            			//navigator.pageControl.element.opacity = '0';
            			cancelAnimationFrame(navigator.layoutProcess);
            			navigator.layoutProcess = requestAnimationFrame(function () {
            				var vw = appView ? appView.value : null;
            				if (control.__checkLayout) {
            					control.__checkLayout(element, vw, navigator._lastViewstate);
            				}
            				else {
            					if (control.updateLayout) {
            						control.updateLayout.call(control, element, vw, navigator._lastViewstate);
            					}
            					var layoutCtrls = element.element.querySelectorAll('.mcn-layout-ctrl');
            					if (layoutCtrls &amp;&amp; layoutCtrls.length) {
            						for (var i = 0 ; i &lt; layoutCtrls.length; i++) {
            							var ctrl = layoutCtrls[i].winControl;
            							if (ctrl.updateLayout)
            								ctrl.updateLayout(ctrl.element, vw, navigator._lastViewstate);
            						}
            					}
            				}
            				//WinJS.UI.Animation.fadeIn(navigator.pageControl.element);
            			});
            		}
            		this._lastViewstate = appView ? appView.value : null;
            	},

            	_handleBack: function () {
            		nav.back();
            	},

            	// Updates the back button state. Called after navigation has
            	// completed.
            	_updateBackButton: function (element) {
            		var ctrl = this;
            		var backButtons = element.querySelectorAll(".win-backbutton, .back-button, .win-navigation-backbutton");
            		//var backButton = this.pageElement.querySelector("header[role=banner] .win-backbutton");

            		if (backButtons &amp;&amp; backButtons.length > 0) {
            			var clearNav = false;
            			//console.log('nav:' + JSON.stringify(args.detail.state))
            			//if (args &amp;&amp; args.detail &amp;&amp; args.detail.state &amp;&amp; args.detail.state.clearNavigationHistory)
            			//    clearNav = args.detail.state.clearNavigationHistory;

            			for (var i = 0, l = backButtons.length; i &lt; l ; i++) {
            				var btn = backButtons[i];
            				if (ctrl.canGoBack &amp;&amp; !clearNav) {
            					btn.classList.remove('disabled');
            					btn.disabled = false;
            				} else {
            					btn.classList.add('disabled');
            					btn.disabled = true;
            				}

            				btn.onclick = function (arg) {
            					if (ctrl.global) {
            						nav.back();
            					}
            					else {
            						var navigator = WinJSContrib.UI.parentNavigator(arg.currentTarget);
            						navigator.back();
            					}
            				}
            			}
            		}
            	}
            }
        ), WinJS.Utilities.eventMixin)
	});

	if (WinJSContrib.UI.WebComponents) {
		WinJSContrib.UI.WebComponents.register('mcn-navigator', WinJSContrib.UI.PageControlNavigator, {
			properties: ['global'],
			map: {
				"ENTERPAGEANIMATION": {
					attribute: "enterPageAnimation",
					property: "animations.enterPage",
					resolve: true
				},
				"EXITPAGEANIMATION": {
					attribute: "exitPageAnimation",
					property: "animations.exitPage",
					resolve: true
				}
			}
		});
	}
})();
</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					by MCNEXT
					<br />
					
					
		<span class="copyright">
		copyright MCNEXT
		</span>
					<br />
					
		<span class="jsdoc-message">
		Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a>
		on Mon Apr 27 2015 13:00:52 GMT+0200 (Romance Daylight Time) using the <a href="https://github.com/terryweiss/docstrap">DocStrap template</a>.
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
